## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

- 加密 : 

  加密前後為一對一關係。將明文資訊改變為密文內容，但可透過解密還原為原本資訊，因此知道密文及密鑰可以還原為原本密碼。

- 雜湊 ( hash ) : 

  加密前後多對一關係，有可能有超過一個 hash 前的資料會在 hash 後成為一樣的內容 (即為碰撞)，因此無法還原。是將資料透過雜湊演算法處理當需要驗證時，則將驗證資料透過同樣的雜湊函式對應儲存的雜湊後資訊，判別是否相同即可。

- 為什麼密碼需要透過雜湊儲存?

  因為加密是一個可逆的方式，只要知道解密的的方法便可以知道原本存取的內容，當密碼被得知以後除了當下的網站資安受到威脅，依照使用者習慣在各大常用網站拿帳密測試，使用者資料也很可能因此破解。
  
  雜湊是一個不可逆的方式，因為其多對一關係的特性，很難回推一開始儲存的密碼是甚麼，因此在網站進行密碼驗證時，是用比對的方式。如果需要更安全的做法，可以使用「加鹽」，在原本的密碼上設定加入某指定字串在某指定位置，因此經過雜湊的資訊不僅更複雜，需要解開「加鹽」所使用的字串及位置又是一番工夫。
  
  

## `include`、`require`、`include_once`、`require_once` 的差別

- `include` | `include_once` : 

  include 語法可以指定特定的 php 檔案，載入其檔案中的全部內容並執行。會放在需要被載入的區塊，在執行到此行語法時才會載入內容。

  如果載入不存在或錯誤的檔案時，之後的程式碼還是可以繼續執行。

  而 include_once是同樣的載入但僅一次，若檔案中出現一個已被載入過的 include 或 include_once 語法時，就不會再載入一次。如果在第一次載入特定檔案後又再重複，可能會引發重複定義常數或函式的衝突。因為被載入的檔案如果已經定義了一個常數或函式，在第二次載入的時候會被視作重複定義，產生錯誤訊息。

-  `require` | `require_once` : 

  會放在 php 程式碼的最前面，在執行之前就會先載入其所指定的檔案，例如常用的函式等，使其變成程式碼可以使用的一部分，在需要被使用的時候再執行。

  如果載入不存在或錯誤的檔案時，會導致之後的程式碼中止。

## 請說明 SQL Injection 的攻擊原理以及防範方法

- 攻擊原理 : 當使用者有意攻擊的時候，透過對 SQL 語法的拼湊在使用者可以自行輸入的欄位中使用一段刻意加入的 SQL 語法片段，和原本網站架構中的 SQL 內容結合成一個有另外作用的 SQL 語法，可能繞過權限驗證去刪改後台內容、得到後台其他使用者資料或插入惡意內容讓網站能夠自動轉址到釣魚網站等等。
- 防範方法 : 使用 Prepared Statement 將 SQL 指令中需要帶入的欄位內容被視為參數來處理，使用的時候資料庫伺服器會先編譯完 SQL 指令之後，再將指定的參數內容套用進去並執行，而不會把參數內容視為 SQL 指令的一部分。因此在這個做法下，當有惡意的片段 SQL 指令內容時，也無法和原本的 SQL 指令連接成為新的 SQL 指令。

##  請說明 XSS 的攻擊原理以及防範方法

- 攻擊原理 :  XSS (*Cross-site scripting*) ，使用者可以在使用者輸入的欄位中使用 HTML 標籤，而只要使用 <script></script>  的標籤，就能夠讓瀏覽器執行這段 Javascript 語法，藉由輸入語法讓原本設定出現單純字串的欄位，變成可以執行的程式碼。因為沒有處理之前，這些語法會被瀏覽器視為程式碼而不是解讀為字串，如果被惡意使用的欄位是所有網站使用者載入網站時都會渲染的內容之一，就能夠攻擊到所有網站使用者。例如可能被導向一個頁面看起來完全一樣但其實是釣魚網站的網址，讓不知情的使用者繼續輸入其所有個人訊息與機密資料等。
- 防範方法 : 在欄位被輸出的時候對所有儲存的字串先做處理，例如課程中使用的 htmlspecialchars() 函式，將 HTML 需要使用的標籤符號轉換為僅能顯示用的編碼，讓相關符號不能執行。

## 請說明 CSRF 的攻擊原理以及防範方法

- 攻擊原理 :  CSRF(*Cross Site Request Forgery*) 跨站請求偽造。駭客可以在其他網頁裡面塞入一個「目標 domain」的連結，利用隱藏的方式將可以發出 GET request 的 連結、可以發出 POST request 的表單不被使用者發現，在瀏覽其他網站的時候神不知鬼不覺的對駭客目標的網站做出攻擊。而當駭客的目標是使用者造訪過的網站，而其網站 SESSION 還在期限內且驗證機制不完全，則這個惡意請求的身分則可能被偽造成使用者本人。

- 防範方法 : 

  1. 使用 php 內建的 session 函式庫，能在 $_SESSION 中設定內容

     - 設定機制如下 :
       - 啟用 session : 使用session_start() 函數
       - 設定session 的變數值 : 產生一組 session-id (為一組亂碼)。
       - 把 $_SESSION 中設定的變數值寫入 session 檔案
       - 將一開始的 session-id 設定到 client 端的 set-cookie。

     - 確認機制如下:
       - 從 cookie 中讀取  session-id 
       - 從 session 檔案中讀取變數值，如果登入時輸入的變數值與 session 檔案中讀取的變數值相同，即身分確認。

     當 session-id 為一組亂碼時，可以防止駭客竊取身分；而 session-id 存在 set-cookie 時，cookie 只會從相同的 domain 帶上來，防止跨domain的攻擊。

  2. 加上圖形驗證碼或簡訊驗證碼。

     - 這個方法通常用在有金流操作的網站，會要求重複的圖形驗證或簡訊驗證碼的確認。

  3. 瀏覽器端的防範方法 : SameSite Cookie

     - 原理是幫 cookie 再加上一層驗證，不允許跨站請求。除了在設定驗證的網站 Domain 發出的請求會帶上此 cookie 以外，其他 domain 發出的 request 都不會帶上這個 cookie。

     

   

