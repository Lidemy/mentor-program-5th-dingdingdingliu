## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

- 加密 : 

  加密前後為一對一關係。將明文資訊改變為密文內容，但可透過解密還原為原本資訊，因此知道密文及密鑰可以還原為原本密碼。

- 雜湊 ( hash ) : 

  加密前後多對一關係，有可能有超過一個 hash 前的資料會在 hash 後成為一樣的內容 (即為碰撞)，因此無法還原。是將資料透過雜湊演算法處理當需要驗證時，則將驗證資料透過同樣的雜湊函式對應儲存的雜湊後資訊，判別是否相同即可。

- 為什麼密碼需要透過雜湊儲存?

  因為加密是一個可逆的方式，只要知道解密的的方法便可以知道原本存取的內容，當密碼被得知以後除了當下的網站資安受到威脅，依照使用者習慣在各大常用網站拿帳密測試，使用者資料也很可能因此破解。
  
  雜湊是一個不可逆的方式，因為其多對一關係的特性，很難回推一開始儲存的密碼是甚麼，因此在網站進行密碼驗證時，是用比對的方式。如果需要更安全的做法，可以使用「加鹽」，在原本的密碼上設定加入某指定字串在某指定位置，因此經過雜湊的資訊不僅更複雜，需要解開「加鹽」所使用的字串及位置又是一番工夫。
  
  

## `include`、`require`、`include_once`、`require_once` 的差別

- `include` | `include_once` : 

  include 語法可以指定特定的 php 檔案，載入其檔案中的全部內容並執行。會放在需要被載入的區塊，在執行到此行語法時才會載入內容。

  如果載入不存在或錯誤的檔案時，之後的程式碼還是可以繼續執行。

  而 include_once是同樣的載入但僅一次，若檔案中出現一個已被載入過的 include 或 include_once 語法時，就不會再載入一次。如果在第一次載入特定檔案後又再重複，可能會引發重複定義常數或函式的衝突。因為被載入的檔案如果已經定義了一個常數或函式，在第二次載入的時候會被視作重複定義，產生錯誤訊息。

-  `require` | `require_once` : 

  會放在 php 程式碼的最前面，在執行之前就會先載入其所指定的檔案，例如常用的函式等，使其變成程式碼可以使用的一部分，在需要被使用的時候再執行。

  如果載入不存在或錯誤的檔案時，會導致之後的程式碼中止。

## 請說明 SQL Injection 的攻擊原理以及防範方法

- 攻擊原理 : 當使用者有意攻擊的時候，透過對 SQL 語法的拼湊在使用者可以自行輸入的欄位中使用一段刻意加入的 SQL 語法片段，和原本網站架構中的 SQL 內容結合成一個有另外作用的 SQL 語法，可能繞過權限驗證去刪改後台內容、得到後台其他使用者資料或插入惡意內容讓網站能夠自動轉址到釣魚網站等等。
- 防範方法 : 使用 Prepared Statement 將 SQL 指令中需要帶入的欄位內容被視為參數來處理，使用的時候資料庫伺服器會先編譯完 SQL 指令之後，再將指定的參數內容套用進去並執行，而不會把參數內容視為 SQL 指令的一部分。因此在這個做法下，當有惡意的片段 SQL 指令內容時，也無法和原本的 SQL 指令連接成為新的 SQL 指令。

##  請說明 XSS 的攻擊原理以及防範方法

- 攻擊原理 :  XSS (*Cross-site scripting*) ，使用者可以在使用者輸入的欄位中使用 HTML 標籤，而只要使用 <script></script>  的標籤，就能夠讓瀏覽器執行這段 Javascript 語法，藉由輸入語法讓原本設定出現單純字串的欄位，變成可以執行的程式碼。因為沒有處理之前，這些語法會被瀏覽器視為程式碼而不是解讀為字串，如果被惡意使用的欄位是所有網站使用者載入網站時都會渲染的內容之一，就能夠攻擊到所有網站使用者。例如可能被導向一個頁面看起來完全一樣但其實是釣魚網站的網址，讓不知情的使用者繼續輸入其所有個人訊息與機密資料等。
- 防範方法 : 在欄位被輸出的時候對所有儲存的字串先做處理，例如課程中使用的 htmlspecialchars() 函式，將 HTML 需要使用的標籤符號轉換為僅能顯示用的編碼，讓相關符號不能執行。

## 請說明 CSRF 的攻擊原理以及防範方法

- 攻擊原理 :  CSRF(*Cross Site Request Forgery*) 跨站請求偽造。駭客可以在其他網頁裡面塞入一個「目標 domain」的連結，利用隱藏的方式將可以發出 GET request 的 連結、可以發出 POST request 的表單不被使用者發現，在瀏覽其他網站的時候神不知鬼不覺的對駭客目標的網站做出攻擊。而當駭客的目標是使用者造訪過的網站，而其網站 SESSION 還在期限內且驗證機制不完全，則這個惡意請求的身分則可能被偽造成使用者本人。

- 防範方法 : 

  **看完第11週直播後，發現自己對這個問題有一些誤解，重新修正作業內容**

  CSRF 的跨站攻擊，如果使用者在被攻擊的 domain 一直保持登入的時候，沒有辦法用 SESSION-ID / cookie 的途徑防止被攻擊。因為跨站攻擊是在不同 domain 底下發送一個避開使用者察覺、針對指定 domain 的 request，因此當原本網站保持登入的情況下，瀏覽器發現有一個針對指定 domain 的 request ，就會帶上其 domain 的 SESSION-ID / cookie 發出 request，後端驗證的時候也驗證 cookie 無誤，就成功的被攻擊了。

  可防範的方法 : 

  1. 加上圖形驗證碼或簡訊驗證碼。

  - 這個方法通常用在有金流操作的網站，會要求重複的圖形驗證或簡訊驗證碼的確認。不會只單靠瀏覽器的操作，需要使用者透過手機號碼等其他方式多次驗證。

  2. 瀏覽器端的防範方法 : SameSite Cookie

  - 原理是幫 cookie 再加上一層驗證，不允許跨站請求。除了在設定驗證的網站 Domain 發出的請求會帶上此 cookie 以外，其他 domain 發出的 request 都不會帶上這個 cookie。

  - 用法 : 在設置 cookie 的 header 加入 "Samsite" 

    ```Set-Cookie: session_id=ewfewjf23o1; SameSite```

  - Strict 模式 : 比較嚴格，從 <a href='...'> 、<form>、new XMLHttpRequest 等發出的所有被驗證不是同一個 site 底下的 request 都不會被帶上 cookie。
    (所以朋友貼一個 IG 貼文跟我分享，但我點進去永遠都不能看，因為是被登出的狀態，應該原因就是這個。)

    這樣的模式會讓使用者體驗不佳，所以有些網站會準備兩組 cookie ，一組不設定 samsite，另一組設定 samsite 則使用在敏感操作上。

  - Lax 模式 : 比較寬鬆。只有 POST 方法的 form ，或用 POST、PUT、DELETE 這些方法就不會帶上 cookie，但也因此無法擋下 GET 形式的攻擊。

  3. 當一個總是登出的使用者。

  

  

  

   

