## 前四週心得與解題心得



#### 第一週 - GIT / Command line

- command line

  過去一直都是使用熟悉的圖形介面（GUI），所以第一次接觸到 CLI 的時候覺得很陌生以及不適應，有一點抗拒，剛看課程影片的時候也覺得學習的效率很低。但增加使用時間之後，覺得指令其實熟悉以後很快能上手，現在即使在使用的時候碰到一些不熟悉的問題，也能透過資料搜尋來解決。
  
  有一個發生在這週（第五週）的事件，是某天突然無法用滑鼠點開開始工具列跟檔案資料夾，重新開機也沒能解決這個問題。google 之後發現網友分享了一個方法是進入到命令提示字元中進行修復。當下的感覺是，命令提示字元我不陌生，這個方式我一定能夠解決。有的時候學習新的事物感覺挫折，並不是那件事情超過自己的能力，只是面對新事物的陌生感而已。
  
- GIT

  GIT 對我來說是 command line 的升級打怪版。其實 github 的頁面到目前來說仍然不是那麼熟悉，因為有很多功能還沒接觸到。但對於版本控制這件事情，多了新的了解，尤其是考慮到多人協作的狀況下，用亂數作為版本控制是過去沒有意識到的部分。
  這週也發生了想從 github 將助教批改完成的作業 merge 回本地 master 的時候，因為 package.json 及 package-lock.json 這兩個檔案出現衝突，無法 merge 成功。我使用了 `git reset --merge`  的作法讓狀態先回到失敗的 merge 之前，然後我決定將遠端的版本當作最正確版本，`git reset --hard origin/master` 處理之後解決了這個問題。

  之前對 git 的基本操作主要是應用在作業上，沒有碰過比較棘手的問題，因此都順利地進行，這次發生了衝突，覺得 git 博大精深果然我還差得遠啊~。

  

#### 第二 & 三週 - 程式基礎

因為曾經有學過 python 的課程，當時就有學到迴圈及判斷式等，因此對這方面比較有一些基礎概念。但反而希望自己在這樣的基礎上，看更多別人的程式碼，去觀摩不同的邏輯。

這兩週對我而言，重點是撰寫「虛擬碼」的過程。從過去的經驗發現，其實自己真的很沒有耐心，拿到題目以後，基本是把虛擬碼在腦中過一遍，但有時候想當然會錯失一些細節；或當題目較為龐雜的時候，這樣的操作就會大大出現問題。

因此在學習進度上自己也常常提到這個部分，後來跟著 「先別急著寫 Leetcode」的實例操作時有訓練自己一步一步的跟著完成。然後寫程式碼時，也能用註解先將自己的思路寫下來，再依照思路細寫程式碼。



#### 第四週 - 網路基礎

這一週是我筆記做最多的一週。

從網路協定開始，Huli 把 API 包進了傳紙條的故事，加上販賣機的原理，成為一個大的架構。但同樣的在學習的過程中，網路上的資源也是看到頭昏眼花，加上這週一開始就進行了 HTTP Challenge，從第十一關卡到臉歪嘴斜，果真是進階題的威力。

也因此在串接 Twitch API 的時候，終於寫了串接心得筆記，把過程記錄下來。

[Twitch API v5 串接實作流程筆記](https://github.com/dingdingdingliu/hackmd/blob/main/Twitch%20API%20v5%20%E4%B8%B2%E6%8E%A5%E5%AF%A6%E4%BD%9C%E6%B5%81%E7%A8%8B%E7%AD%86%E8%A8%98%20.md)



#### 小挑戰 1 - Lidemy HTTP Challenge

這個小挑戰我有把每一關都另存一個 js 檔案以做紀錄，之後會寫完整解題過程筆記。

前十關的確是基礎題，第一二關只要帶入指定的 querystring 就可以過關，第三關的時候一時沒想到把 body 印出來就可以過關，卡了一陣子決定把 response 和 body 都印出來 ( 這就是console.log 的威力)，就這麼解題了。
十題的過程中，一關一關的去認識新的東西，例如 :

1. 第四關的 encodeUrl 編碼字串
2. 第六關的 base64 ( 分 encode和decode )

以及在 headers 當中需要帶入的各種參數，當然還有過程中把 Javascript 再運用練習。



#### 小挑戰 2 - LIOJ 三題

- 不合群的人

這一題主要在思路上解決了如何將陣列內容分成 A & B 兩組，以及後面判斷式的條件需要想得仔細，當所有人都在同一組或者是兩組一樣人數的狀況，就是PEACE。

有設定兩個空陣列存放 A 及 B 出現的位置，如果是不合群的狀態，再迭代印出陣列中位置即可。

- 貪婪的小偷

這一題主要也是在條件的判斷上要考慮比較多，有可能小偷能拿的數量是 0 ，那後面不管有多少價值的物品，他都不能拿。

另外如果他能拿的數量比價值物品的數量多，那就是全拿。

最後的條件是小偷能拿的數量比價值物品數量少，這時候再用 `sort()` 排順序取數量加總。

這邊有特別 google 一下 `sort() ` 如何設定大小條件的寫法，以數字為例，不設定條件的情況下陣列中數字會由小而大排列，但因為我想要由大而小排列，所以改用以下的寫法。

```javascript
newArr.sort((a, b) => b - a)
```

- 大平台

這一題反而讓我卡題最久，後來還貼上自己的程式碼到群組上，感謝同學點出了我的盲點。

這個盲點就是，我按照一般階梯的邏輯去想，覺得不可能第一階跳到第三階，殊不知就是因為這樣漏掉了過程中可能會是不連續數字的情形。

當中間數字出現不連續情形時，對其進行 `indexof()` 會回傳 `-1` ，因此在長度計算上會計算錯誤。

意識到這個問題之後，決定只要出現 -1 的時候都跳過不計其情況，用 if 判斷式把這個情況排除，終於順利完成題目。

