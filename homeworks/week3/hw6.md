## hw1：好多星星

1. 解題的關鍵是要先設立一個空字串，而且必須建立在迴圈之外，否則每次執行迴圈內容，字串都會變成空字串。

   `let str = ''`

2. 每次結束一個迴圈時，字串必須更新為上一個迴圈中已經加入星星的那個字串，才能在原本的數量上多加一個，印出排數和個數相同的星星圖案。

   ` for (let i = 1; i <= number; i++) {
       str += '*'
       console.log(str)
     }`

## hw2：水仙花數

寫完這題回去看了課程影片，發現自己就是用了那個偷吃步的取字串寫法，但因為一開始就是用這個想法來解，所以還是保留這個答案。

會這樣想的原因來自於作業當中的敘述 :

> 153 是三位數，而 1^3 + 5^3 + 3^3 = 15313+53+33=153

所以很直覺就是把 153 這個數字轉為字串後取出每一個字分別次方後相加，來判斷是否為水仙花數。

不過後來看了影片也 google 一下別人的解法，有再用 10 進位的取個十百位數的方式思考了一下這題。

## hw3：判斷質數

1. 首先將範圍內的數字建立一個迴圈，每個迴圈都將當前數字的因數 push 進一個空陣列中。

   `const num = Number(lines[time])
   const arr = []
   for (let i = 1; i <= num; i++) {
     if (num % i === 0) {
       arr.push(i)
     }
   }`

2. 接下來因為判斷如果當前數字為質數的話，因數必定只有兩個，其他一定都不是質數 ( 1 因為只有一個因數，1 也不是質數)。

   所以設定只要陣列的長度為 2 的，就是質數，其他的都不是。

## hw4：判斷迴文

這題建立一個字串，賦值為原字串的反轉字串。

反轉的方式 : 

`const strB = strA.split('').reverse().join('')`

&rArr; `strA.split('')` : 先將 strA 轉為陣列

&rArr; `strA.split('').reverse()` : 反轉其陣列

&rArr; `strA.split('').reverse().join()` : 將反轉後的陣列轉回字串

接下來判斷兩字串若相等，則為迴文。 

## hw5：聯誼順序比大小

看了 Unit 3-2 的影片，思考了一下在數字位數很長的狀況下應該如何比大小。

1. 比大小的條件 : 原本想將兩個條件 ( '1' || '-1' ) 分別比較，但程式內容變成相當複雜，if條件式很多很亂。

   後來參考同學的作業，原來可以假設所有比較都是比大，當條件為 '-1' ( 即比小 ) 的時候，將 a、b 所指定的兩個數字對調 : 

   `if (r === '-1') {
     const temp = a
     a = b
     b = temp
   `

   `}`

   由於不用印出數字，只要印出 'A' ( 位置 )或 'B' ( 位置 )，因此等同於在同樣比大的條件下，印出相反位置，達到比小的要求。

   

2. 關於數字的範圍 : 決定用長度 ( 即位數 ) 來比較，可以將極大的數字轉成長度 ( 最長不超過512 ) ，用長度作為比大小的條件 : 

   `if (a.length !== b.length) {
     return a.length > b.length ? 'A' : 'B'
   }`



